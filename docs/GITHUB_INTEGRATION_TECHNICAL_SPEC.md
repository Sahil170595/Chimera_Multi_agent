# GitHub Integration: Muse Protocol Repository Management

## Overview

The GitHub integration serves as the **version control backbone** and **deployment trigger** for the Muse Protocol. It manages content repositories, tracks code changes, triggers deployments, and provides git-based correlation for all generated episodes and performance data.

**Primary Repositories:**
- **Banterblogs**: `https://github.com/Sahil170595/ai-agents-hackathon` (Content publishing)
- **Banterpacks**: Private repository (Streaming overlay system)
- **Banterhearts**: Private repository (LLM optimization platform)
- **Chimera Multi-agent**: `https://github.com/Sahil170595/Chimera_Multi_agent` (Current project)

---

## Architecture Role

### Primary Functions

1. **Content Version Control**: Manages episode files and content updates
2. **Deployment Triggers**: Automatically triggers Vercel deployments on content changes
3. **Git Correlation**: Links all performance data to specific git commits
4. **Collaboration Platform**: Enables team collaboration on content and code
5. **Change Tracking**: Monitors repository activity for agent processing
6. **Branch Management**: Handles content staging and production workflows

### Integration Points

- **Publisher Agent**: Commits episodes and triggers deployments
- **Collector Agent**: Monitors commits for processing
- **Watcher Agent**: Validates data freshness against latest commits
- **Vercel**: Receives webhook triggers for automatic deployments
- **ClickHouse**: Stores commit metadata for correlation analysis

---

## Technical Implementation

### GitHub API Integration

**Authentication:**
```python
# Personal Access Token (PAT) authentication
GITHUB_TOKEN = "your_github_token_here"
```

**API Endpoints Used:**
- `GET /repos/{owner}/{repo}/commits` - Fetch commit history
- `POST /repos/{owner}/{repo}/contents/{path}` - Create/update files
- `GET /repos/{owner}/{repo}/git/refs/heads/{branch}` - Get branch references
- `POST /repos/{owner}/{repo}/git/refs` - Create branch references
- `POST /repos/{owner}/{repo}/git/commits` - Create commits
- `POST /repos/{owner}/{repo}/git/refs/{ref}` - Update references

### Repository Structure

**Banterblogs Content Structure:**
```
banterblogs-nextjs/
├── posts/
│   ├── banterpacks/
│   │   ├── ep-001.md
│   │   ├── ep-002.md
│   │   └── ...
│   └── chimera/
│       ├── ep-001.md
│       ├── ep-002.md
│       └── ...
├── public/
├── components/
└── pages/
```

**Episode File Format:**
```markdown
---
title: "Episode Title"
series: "banterpacks" | "chimera"
episode: 1
date: "2025-10-07T20:50:43Z"
models: ["gpt-4", "claude-3"]
run_id: "b701af3b-1e66-4a17-8122-59ce95d53e19"
commit_sha: "a16e4c8f2e3c6cd829ace8706a84cf25283897e5"
latency_ms_p95: 1250
tokens_in: 1500
tokens_out: 800
cost_usd: 0.010335
---

## What changed
[Content about recent changes]

## Why it matters
[Analysis of impact]

## Benchmarks (summary)
[Performance metrics]

## Next steps
[Future plans]

## Links & artifacts
[References and resources]
```

---

## Agent Integration Specifications

### Publisher Agent - GitHub Operations

**Primary Functions:**
1. **File Creation**: Creates new episode files in appropriate directories
2. **Commit Management**: Commits episodes with descriptive messages
3. **Branch Handling**: Manages content branches and merges
4. **Deployment Triggers**: Triggers Vercel deployments via webhooks

**Technical Implementation:**
```python
class PublisherAgent:
    def __init__(self, git_client: GitClient, vercel_client: VercelClient):
        self.git_client = git_client
        self.vercel_client = vercel_client
    
    def commit_episode(self, episode_data: Dict[str, Any]) -> Dict[str, Any]:
        """Commit episode to GitHub repository."""
        # 1. Create episode file with front-matter
        # 2. Add to git staging
        # 3. Commit with descriptive message
        # 4. Push to main branch
        # 5. Trigger Vercel deployment
```

**Commit Message Format:**
```
feat(episode): Generate {series} episode {episode_num}

- Title: {episode_title}
- Confidence: {confidence_score}
- Correlation: {correlation_strength}
- Cost: ${cost_total}
- Run ID: {run_id}

Generated by Muse Protocol Council Agent
```

**File Path Strategy:**
- **Banterpacks Episodes**: `posts/banterpacks/ep-{num:03d}.md`
- **Chimera Episodes**: `posts/chimera/ep-{num:03d}.md`
- **Episode Numbering**: Sequential within each series

### Collector Agent - Commit Monitoring

**Primary Functions:**
1. **Commit Discovery**: Scans repositories for new commits
2. **Change Analysis**: Analyzes commit messages and file changes
3. **Metadata Extraction**: Extracts relevant information from commits
4. **Data Correlation**: Links commits to performance data

**Technical Implementation:**
```python
class CollectorAgent:
    def collect_commits(self, hours_back: int = 24) -> List[Dict[str, Any]]:
        """Collect commits from monitored repositories."""
        commits = []
        
        # Scan Banterpacks repository
        packs_commits = self.git_client.get_commits(
            repo="Banterpacks",
            since=f"{hours_back} hours ago"
        )
        
        # Scan Banterhearts repository  
        hearts_commits = self.git_client.get_commits(
            repo="Banterhearts", 
            since=f"{hours_back} hours ago"
        )
        
        # Process and correlate commits
        return self.process_commits(packs_commits + hearts_commits)
```

**Commit Processing Logic:**
1. **Filter Relevant Commits**: Focus on performance-related changes
2. **Extract Metadata**: Parse commit messages for key information
3. **Correlate with Data**: Link commits to benchmark runs
4. **Store in ClickHouse**: Insert commit data into ui_events table

### Watcher Agent - Data Freshness Validation

**Primary Functions:**
1. **Commit Tracking**: Monitors latest commits across repositories
2. **Data Synchronization**: Ensures ClickHouse data matches git state
3. **Freshness Validation**: Validates data is current and complete
4. **Pipeline Gating**: Blocks pipeline if data is stale

**Technical Implementation:**
```python
class WatcherAgent:
    def check_data_freshness(self) -> Tuple[str, int, int, int]:
        """Check data freshness against latest commits."""
        # Get latest commits
        packs_commit = self.git_client.get_latest_commit("Banterpacks")
        hearts_commit = self.git_client.get_latest_commit("Banterhearts")
        
        # Check ClickHouse data freshness
        packs_rows = self.clickhouse.get_rows_since_commit(packs_commit)
        hearts_rows = self.clickhouse.get_rows_since_commit(hearts_commit)
        
        # Calculate lag
        lag_seconds = self.calculate_lag(packs_commit, hearts_commit)
        
        return self.determine_status(packs_rows, hearts_rows, lag_seconds)
```

**Freshness Criteria:**
- **Banterpacks**: Must have UI events within 90 minutes of latest commit
- **Banterhearts**: Must have benchmark runs within 5 minutes of latest commit
- **Maximum Lag**: 4 hours before pipeline is blocked

---

## Git Workflow Integration

### Content Publishing Workflow

**1. Episode Generation:**
```
Council Agent → Generate Episode → Publisher Agent
```

**2. GitHub Operations:**
```
Publisher Agent → Create File → Commit → Push → Trigger Deployment
```

**3. Deployment Pipeline:**
```
GitHub Push → Vercel Webhook → Build → Deploy → Notify
```

### Branch Strategy

**Main Branch (`main`):**
- **Purpose**: Production content and stable code
- **Protection**: Requires pull request reviews
- **Deployment**: Automatically deploys to production

**Content Branches (`content/episode-{num}`):**
- **Purpose**: Draft episodes and content staging
- **Workflow**: Create → Review → Merge → Deploy
- **Cleanup**: Auto-deleted after merge

**Development Branches (`dev/feature-{name}`):**
- **Purpose**: Feature development and testing
- **Integration**: Merged to main via pull requests
- **Testing**: Deployed to staging environment

---

## Data Correlation and Analytics

### Git Commit Correlation

**ClickHouse Integration:**
```sql
-- Link episodes to git commits
SELECT 
    e.title,
    e.series,
    e.commit_sha,
    e.confidence_score,
    e.cost_total
FROM episodes e
WHERE e.ts >= now() - INTERVAL 7 DAY
ORDER BY e.ts DESC;

-- Correlate performance with commits
SELECT 
    br.commit_sha,
    br.model,
    br.latency_p95_ms,
    br.tokens_per_sec,
    br.cost_per_1k
FROM bench_runs br
WHERE br.commit_sha != '0000000000000000000000000000000000000000'
ORDER BY br.ts DESC;
```

**Correlation Analysis:**
- **Performance Impact**: Link benchmark improvements to specific commits
- **Content Quality**: Correlate episode quality with code changes
- **Cost Analysis**: Track LLM usage costs per commit
- **Deployment Success**: Monitor deployment success rates

### Repository Activity Monitoring

**Commit Volume Tracking:**
```sql
-- Daily commit activity
SELECT 
    toDate(ts) as day,
    count(*) as commit_count,
    countDistinct(commit_sha) as unique_commits
FROM ui_events 
WHERE ts >= now() - INTERVAL 30 DAY
GROUP BY day
ORDER BY day;
```

**Repository Health Metrics:**
- **Commit Frequency**: Commits per day/week
- **File Change Volume**: Lines changed per commit
- **Branch Activity**: Active branches and merge frequency
- **Collaboration Metrics**: Contributors and review activity

---

## Security and Access Control

### Authentication Strategy

**Personal Access Tokens (PAT):**
- **Scope**: Repository read/write access
- **Expiration**: 90-day rotation cycle
- **Permissions**: Minimal required permissions
- **Storage**: Encrypted in environment variables

**Repository Access:**
- **Public Repositories**: Read access for monitoring
- **Private Repositories**: Full access for content management
- **Organization Repositories**: Team-based access control

### Security Best Practices

**Token Management:**
- **Environment Variables**: Store tokens securely
- **Rotation Policy**: Regular token rotation
- **Audit Logging**: Track token usage
- **Scope Limitation**: Minimal required permissions

**Repository Security:**
- **Branch Protection**: Prevent direct pushes to main
- **Code Review**: Require pull request reviews
- **Secrets Scanning**: Scan for exposed credentials
- **Dependency Updates**: Regular security updates

---

## Error Handling and Resilience

### Failure Scenarios

**1. GitHub API Rate Limiting:**
- **Detection**: Monitor API response codes
- **Response**: Implement exponential backoff
- **Fallback**: Queue operations for retry

**2. Repository Access Issues:**
- **Detection**: Monitor authentication errors
- **Response**: Alert and retry with fresh tokens
- **Fallback**: Continue with cached data

**3. Commit Conflicts:**
- **Detection**: Monitor merge conflicts
- **Response**: Automatic conflict resolution
- **Fallback**: Manual intervention required

### Retry Logic

**Exponential Backoff:**
```python
@retry(
    stop=stop_after_attempt(3),
    wait=wait_exponential(multiplier=1, min=4, max=10),
    retry=retry_if_exception_type(GitHubAPIError)
)
def git_operation_with_retry(operation):
    return operation()
```

**Dead Letter Queue:**
- **Failed Operations**: Store in DLQ for manual review
- **Retry Scheduling**: Automatic retry with increasing delays
- **Alerting**: Notify on persistent failures

---

## Monitoring and Observability

### GitHub Integration Metrics

**Custom Metrics:**
- `muse.github.commits_processed`: Commits processed per hour
- `muse.github.files_created`: Files created per hour
- `muse.github.api_calls`: GitHub API calls per hour
- `muse.github.rate_limit_remaining`: API rate limit remaining
- `muse.github.operation_duration`: Operation duration in milliseconds

**Error Tracking:**
- `muse.github.api_errors`: GitHub API errors per hour
- `muse.github.auth_failures`: Authentication failures
- `muse.github.rate_limit_hits`: Rate limit violations

### Dashboard Integration

**GitHub Widgets in Datadog:**
- **Commit Activity**: Daily commit volume trends
- **Repository Health**: Branch activity and collaboration metrics
- **API Usage**: GitHub API call patterns and rate limits
- **Deployment Triggers**: GitHub webhook success rates

---

## Future Enhancements

### Planned Improvements

**Advanced Git Operations:**
- **Automated PR Creation**: Create pull requests for content changes
- **Code Review Integration**: Automated code review workflows
- **Branch Automation**: Automatic branch creation and management

**Enhanced Analytics:**
- **Commit Impact Analysis**: Measure impact of commits on performance
- **Collaboration Metrics**: Track team collaboration patterns
- **Content Quality Correlation**: Link git changes to content quality

**Integration Expansions:**
- **GitHub Actions**: CI/CD pipeline integration
- **GitHub Packages**: Package management integration
- **GitHub Security**: Security scanning and compliance

---

This GitHub integration represents the **version control foundation** of the Muse Protocol, enabling seamless content management, deployment automation, and comprehensive change tracking across the entire system.
